# JAVA 객체지향 프로그래밍

## 1. 변수와 메소드

### 1.1 변수란?

변할 수 있는 데이터를 의미합니다. 변수의 특징은 변수에 담겨있는 어떤 값을 다른 데 있도록 바꿀 수 있다는 것입니다. 이것은 마치 사람이 사용하는 자연어에서 대명사와 비슷한 역할을 합니다 '그','그녀','그것'이 가리키는 것이 정확히 정해져 있지 않고 맥락이나 상황에 따라 가리키는 대상이 달라지는 것처럼 변수 역시 그렇습니다.

### 1.2 변수를 만들고 사용하는 방법

변수를 만들고 사용할 때는 선언(declare)과 할당(assign)이라는 표현을 씁니다. 변수를 선언하는 구문은 두가지 요소인 데이터형식과 변수의 이름으로 구성돼 있습니다.

- int a; : a라는 변수를 선언했고, 앞에있는 int라는 것은 a라는 변수에 담을 수 있는 값이 숫자입니다.(int는 데이터형식, a는 변수의 이름)

### 2. 문자열

first라는 이름의 변수를 선언하는데, 이때 문자열을 담을 수 있는 변수로 만들기 위해서는 데이터타입을 String으로 지정해야 합니다.

```
String first = "coding";
System.out.println(first + " " + "everybody");
```

## 2. 상수

### 2.1 상수란?

상수는 변하지 않는 값을 의미합니다.

- int a=1; : a는 변수이고 1은 상수입니다.

int대신 실수형 데이터 타입에 해당하는 float으로 변수의 데이터 타입을 바꾸어보겠습니다.

```
float a=2.2;
```

그러나 타입 불일치 에러가 나타납니다. float는 실수이고 2.2 역시 실수인데 두 가지가 매칭되지 않는다는 에러가 나타납니다. 그럼 어떻게 해야 이 문제를 해결할 수 있을까요?

```
double a=2.2;
```

위와 같이 바꾸고 저장하면 에러가 사라집니다. 2.2라는 실수는 데이터 타입이 double형이라는 것인데 도대체 float라고 하는 데이터타입은 사용하지도 못하는데 왜 만든 걸까요?

```
float a=2.2F;
```

float도 사용할 수 있습니다. 상수 뒤에 F라는 기호를 붙여서 F가 속한 숫자(상수)가 float 데이터 타입이라는 것을 명시적으로 지정하였기 때문입니다.

```
long a=2147483648L;
```

int보다 큰 수를 담을 수 있는 long으로 데이터 타입을 바꿔보면 상수 뒤에 L을 붙여서 명시적으로 long이라고 지정해야 합니다.  
그러나 int,byte,short는 상수 뒤에 무언가를 붙이지 않아도 되는데, 자바에서는 편의를 제공하기 위해 byte,short 데이터 타입에서 int형 데이터 타입을 사용하는 것이 허용되기 때문입니다. 단 byte나 short로 표시할 수 있는 데이터의 범위를 넘지 않아야 합니다.

## 3. 객체지향이전의 코딩

프로그래밍의 아주 중요한 원칙 중 하나는 중복의 제거입니다. 즉, 중복되는 코드가 있다면 그 코드는 제거해야 할 대상입니다. 그래서 하나의 코드로 중복되는 작업을 할 수 있게 해야만 재활용성, 유지보수의 편의성, 가독성과 같은 것들이 좋아집니다.

### 객체화1

this.left=left에서 this.의 의미는 c1이 담겨있는 Calculator클래스를 구체적으로 만든 인스턴스를 가리키는 것으로, this는 인스턴스 자신을 의미합니다. 그리고 오른쪽의 left는 setOperands클래스 안에 선언한 매개변수 left를 의미합니다.

Calculator c1=new Calculator(); 는 객체를 만드는 구체적인 문법으로, Calculator라는 객체를 새로 만든 다음 Calculator라는 객체를 c1이라는 변수에 담았습니다.

```
package calc;
class Calculator{
	int left, right;

	public void setOprands(int left, int right){
		this.left=left;
		this.right=right;
	}
	public void sum() {
		System.out.println(this.left+this.right);
	}
	public void avg() {
		System.out.println((this.right+this.right)/2);

	}
}

public class CalculatorDemo4 {

public static void main(String[] args) {
	Calculator c1=new Calculator();     //c1 인스턴스 생성
	c1.setOprands(10,20);
	c1.sum();
	c1.avg();
}
}
```

## 4. 클래스 맴버와 인스턴스 맴버

클래스가 설계도라고 한다면 인스턴스는 그 설계도에 따라서 만들어진 구체적인 제품이라고 할 수 있습니다.
인스턴스와 인스턴스를 구분하는 핵심적인 기준은 그 인스턴스 안에 들어 있는 변수의 값, 즉 각 인스턴스가 가지고 있는 상태라는 것입니다. 그러한 상태에 따라 인스턴스에 어떤 행위를 하게 되면 그 행위는 구체적으로 메소드를 실행하는 것에 해당합니다.

클래스의 맴버는 그 클래스(설계도)의 구성원이고, 인스턴스의 맴버(구체적인 제품)의 구성원이라는 뜻입니다. 그리고 객체는 변수와 메소드의 집합이라고 설명했습니다. 그래서 클래스를 정의할 때도 변수와 메소드를 클래스에 정의하지만 그 클래스를 구체적인 제품인 인스턴스로 만들면 인스턴스 안에는 해당 클래스에서 정의된 변수와 메소드가 존재합니다. 바로 그러한 것들이 인스턴스의 멤버입니다.

### 4.1 클래스 메소드

이번 예제에서는 인스턴스가 존재하지 않습니다.이 예제에서 집중해야 할 부분은 인스턴스가 등장하지 않고 '클래스.sum()','클래스.avg()' 형식으로 클래스에 직접 접근해서 sum()과 avg()메소드를 호출한다는 점입니다.
static이 지정된 클래스 메소드는 static이 지정되지 않은 인스턴스 메소드와 달리 클래스를 통해 직접 접근해서 실행할 수 있다는 차이가 있습니다. 클래스에 직접 접근해서 실행할 수 있다는 것입니다.

```
package calc;
class Calculator3{
	public static void sum(int left, int right) {
		// TODO Auto-generated method stub
		System.out.println(left + right);

	}
	public static void avg(int left, int right) {
		// TODO Auto-generated method stub
		System.out.println((left+right)/2);
	}
}


public class CalculatorDemo3 {
	public static void main(String[] args) {
		Calculator3.sum(10,20);
		Calculator3.avg(10,20);

		Calculator3.sum(20,40);
		Calculator3.avg(20,40);

	}

}
```

### 4.2 타입별 비교

1. 인스턴스 메소드는 클래스 맴버에 접근 할 수 있다.
2. 클래스 메소드는 인스턴스 맴버에 접근할 수 없다.  
   인스턴스 변수는 인스턴스가 만들어지면서 생성되는데, 클래스 메소드는 인스턴스가 생성되기 전에 만들어지기 때문에 클래스 메소드가 인스턴스 맴버에 접근하는 것은 존재하지 않는 인스턴스 변수에 접근하는 것과 같다.

## 5. 유효범위

### 5.1 전역변수, 지역변수

메소드 정의에 속한 것이 아니라 클래스 정의에 직접적으로 속한 변수를 전역변수(global variable)라고 하고, a()메소드 안에 선언된 변수를 지역변수(local variable)이라고 합니다.

```
package scope;

public class ScopeDemo {
	static void a() {
		int i=0; //지역변수
	}

	public static void main(String[] args) {
		for(int i=0; i<5 ; i++) {
			a();
			System.out.println(i);
		}
	}

}
```

아래와 같이 i변수를 메소드 바깥쪽의 클래스 영역에 선언하고 a()메소드의 i는 값을 선언하지 않고 할당만 했으며, for문에서도 i변수를 사용하기 전에 선언하지 않고 할당만 했습니다.  
a()메소드 안에는 i의 값을 0으로 바꾸는 어처구니없는 로직이 들어있습니다. 그럼 i의 값이 다시 0이 됩니다. 그래서 println()을 실행하면 0이 화면에 출력됩니다. 그렇게 되면 계속 i의 값은 0이기 때문에 무한루프에 빠지게 됩니다.

```
package scope;

public class ScopeDemo2 {
static int i;   //전역변수
static void a() {
	i=0;
}
public static void main(String[] args) {
	for(i=0;i<5;i++) {
		a();
		System.out.println(i); //무한루프
	}
}
}
```

## 6. 메소드

### 6.1 메소드란?

메소드나 객체지향 같은 개념은 웅장하고, 결함이 없고, 유지보수하기 쉬운 애플리케이션을 만들기 위한 기법이다.

즉, 메소드나 이후에 배울 여러가지 개념은 여러분이 크고 복잡하고 버그가 없는 소프트웨어를 잘 만들기 위한 일종의 관리 도구 또는 매니지먼트 시스템과 같은 것이라고 생각 할 수 있습니다.

### 예제) 메소드선언

delimiter변수를 ex2메소드에 선언해야 다른 메소드안에서도 똑같이 적용할 수 있다.  
하지만 main메소드 안에 선언한다면 다른 메소드에서는 적용이 안된다.

```
public class ex2 {
    public static String delimiter = "";

    public static void main(String[] arg) {
        delimiter = "----";
        printA();
        printA();
        printB();
        printB();

        delimiter = "****";
        printA();
        printA();
        printB();
        printB();

    }

    private static void printA() {
        System.out.println("delimiter");
        System.out.println("A");
        System.out.println("A");
    }

    private static void printB() {
        System.out.println("delimiter");
        System.out.println("A");
        System.out.println("A");
    }
}
```
